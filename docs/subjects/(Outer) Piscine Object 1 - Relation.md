# Subject 번역

> 이 문서에서는 객체지향 프로그래밍의 또 다른 중요한 파트인 `객체 적합성`에 대해 소개합니다. (역: 진짜 적합성인 propriety 인지 property의 오기인지 모르겠음)

## Preamble

객체 지향 프로그래밍에서 객체는 서로 관계를 맺어 상호 작용하고 데이터를 공유할 수 있습니다. 객체가 서로 연관되는 방식은 의존성과 소유권의 정도에 따라 여러 유형으로 분류할 수 있습니다.

예를 들어, 하나의 객체가 다른 객체로 구성되어 있고, 포함된 객체는 메인 객체의 기능에 필요한 객체와 같은 관계가 있습니다. 이 관계는 객체 간의 강한 결합과 한 객체가 다른 객체에 의존하는 것을 나타냅니다.

또 다른 유형의 관계는 객체가 느슨하게 연결되어 있고 한 객체가 다른 객체 없이 독립적으로 작동할 수 있는 경우입니다. 이 관계는 객체 간의 느슨한 결합을 나타냅니다.

마지막으로, 객체가 공통의 책임을 갖지만 어느 객체도 다른 객체에 종속되지 않는 관계가 있습니다. 이 관계는 객체 간의 협업을 나타냅니다.

## Introduction

다음 예제에서는 컴퓨터 시스템을 객체로 사용하여 객체 지향 프로그래밍의 다양한 관계를 설명합니다. 컴퓨터 시스템을 객체로 사용하면 이러한 관계가 실제 상황에 어떻게 적용되고 코드를 구성, 유지 관리 및 확장하는 데 도움이 되는지 확인할 수 있습니다.

중앙 처리 장치(CPU)와 스크린은 서로 느슨한 관계를 가질 수 있는 객체로, 즉 스크린은 별도의 객체이지만 컴퓨터와 연결하여 컴퓨터의 기능에 기여할 수 있습니다. 스크린은 독립적으로 존재할 수 있지만 컴퓨터와 연결하면 디스플레이 기능을 향상시키는 데 도움이 됩니다.

반면에 CPU와 그래픽 처리 장치(GPU)는 강력한 관계를 가질 수 있는데, GPU는 컴퓨터의 일부이며 컴퓨터 없이는 존재할 수 없습니다. 컴퓨터는 주요 객체로, GPU는 컴퓨터의 기능에 필요한 부속 객체로 볼 수 있습니다.

또한 컴퓨터와 프린터 객체는 관계를 가질 수 있는데, 컴퓨터와 프린터는 문서 인쇄라는 공통된 책임을 갖지만 어느 객체도 다른 객체에 종속되지 않습니다. 컴퓨터는 연결된 모든 프린터로 인쇄할 수 있고 프린터는 모든 컴퓨터로부터 인쇄 작업을 받을 수 있습니다. 두 객체는 인쇄 작업을 수행하기 위해 협업하지만 독립적으로 작동할 수도 있습니다.

마지막으로 중앙 처리 장치는 부모 클래스이고 프로세서 객체는 자식 클래스입니다. 프로세서 객체는 클럭 속도 및 코어 수와 같은 CPU 클래스의 속성 및 동작을 상속합니다. 그러나 프로세서 객체는 프로세서의 제조업체 및 모델과 같은 특정 정보를 추가하여 CPU의 속성과 동작을 특수화하기도 합니다.

이 모듈에서는 이 주제와 관련된 4가지 예제를 찾을 수 있습니다! 어떤 이름이 어떤 종류의 관계에 해당하는지 맞춰보세요!

## General rules

-   당신의 프로그램은 어떤 상황에서도 (메모리가 부족한 경우에도) 크래시가 발생하거나 예상치 못하게 종료되어선 안됩니다. 만약 그렇다면, 당신의 프로젝트는 작동하지 않는 것으로 고려되어 0점을 받게 됩니다.
-   relink되지 않는 `Makefile`을 통해 소스 파일을 컴파일해야 합니다.
-   `Makefile`은 최소 다음의 규칙을 가집니다: `$(NAME)`, `all`, `clean`, `fclean`, `re`
-   `c++`와 `-Wall -Wextra -Werror` 플래그로 컴파일해야 합니다.
-   반드시 **`C++98 표준`** 을 지켜야합니다. `-std=c++98` 플래그를 붙여도 정상적으로 컴파일되어야 합니다.
-   항상 가능한 한 많은 C++ 함수를 사용하여 개발하세요(예: `<string.h>` 대신 `<cstring>` 선택). C 함수를 사용할 수 있지만 가능하면 항상 C++ 버전을 선호하세요.
-   어떤 외부 라이브러리와 `Boost` 라이브러리는 금지됩니다.

## Ex 00 : Putting it into practice

> Ex00: 실행에 옮기기
> `ex00/*.cpp`, `ex00/*.hpp`, `ex00/main.cpp`, `ex01/Makefile` 제출
> 표준 STD 컨테이너와 자료구조 허용

[서문](#Preamble)과 [서론](#Introduction)을 읽어보시면 정말 유용한 지식을 발견하실 수 있을 것입니다.

평가 중에는 객체 지향 프로그래밍의 특정 용어에 대한 질문을 받게 되므로 인터넷에서 정의를 검색하여 자신의 것으로 만들어 보세요!

아키텍처와 코드 계획을 평가하기 위한 것이므로 메서드의 코드를 헤더 파일 안에 직접 배치할 수 있지만 선언과 분리하는 것이 더 명확하다고 생각되면 `.cpp`를 자유롭게 생성할 수 있습니다.

이 모듈에서 생성하는 거의 모든 함수, 메서드, 생성자, 연산자 및 소멸자에 출력을 배치할 것으로 예상합니다.

이러한 출력은 평가 중에 코드가 어디로 이동하는지, 어떤 작업을 수행하는지, 어떤 순서로 수행하는지 확인하는 데 사용됩니다.

따라서 필요한 곳에 출력을 배치하세요!

### 1. Composition

이 섹션에서는 다음 구조를 생성해야 합니다:

-   `int x`, `int y`, `int z` 를 가지는 `Position`
-   `int level`, `int exp` 를 가지는 `Statistic`
-   `Position`과 `Statistic`을 포함하는 `Worker`

`Worker`는 반드시 `Position`과 `Statistic`을 **구성 요소**로 가지고 있어야 합니다.

> 평가 중에 이 문장이 무엇을 의미하는지에 대한 질문을 받을 준비를 하세요.

### 2. Aggregation

메서드 사용으로 `Shovel` 클래스를 추가해야 합니다. `Shovel`은 `Worker`에게 주었다가 필요한 경우 가져갈 수 있어야 합니다.
`Worker`를 삭제하는 경우, `Shovel` 은 파괴되지 않아야 합니다.

반드시 다음 태스크를 수행해야 합니다:

-   `numberOfUses`를 가지는 `Shovel`
-   `Shovel` 객체를 주고 받을 수 있도록 `Worker` 클래스 수정
-   `Worker` 객체의 삭제에도 `Shovel` 객체가 삭제되지 않도록 하기
-   `Shovel`이 어떤 `Worker`에게 이미 주어졌을 때, 다른 `Worker`에게 주면 기존 `Worker` 에게서 도구가 제거되는지 확인

### 3. Inherence

순수 가상함수 `use`를 가지는 추상 클래스 `Tool`을 추가해야 합니다. `Shovel`은 `Tool`을 상속합니다. `Tool`을 상속하는 다른 클래스인 `Hammer`를 추가해야 합니다.

각 도구에는 사용 횟수를 가져야 하며, 어떤 도구인지를 나타내는 `use` 메서드가 있어야 합니다. 이제 `Worker`는 여러 도구를 동시에 사용할 수 있어야 하며 도구를 반환할 수 있어야 합니다.

반드시 다음 태스크를 수행해야 합니다:

-   추상 클래스 `Tool` 생성
-   `Shovel`이 `Tool`을 상속받도록 하기
-   `Tool`을 상속하는 `Hammer`클래스 작성
-   도구들이 `Worker`에게 주어질 수 있고, 다시 수거할 수 있는지 확인
-   도구가 어떤 `Worker`에게 이미 주어졌을 때, 다른 `Worker`에게 주면 기존 `Worker` 에게서 도구가 제거되는지 확인

### 4. Association

워크샵에서 일할 수 있는 `Worker` 목록이 있는 `Workshop` 클래스를 만들어야 합니다. `Workshop` 클래스에는 워크샵의 `Worker` 목록에 가입하고 자유롭게 탈퇴할 수 있는 방법이 있어야 합니다.

여러분에게는 다음과 같은 임무가 주어집니다:

1. `Workshop` 클래스 만들기
2. `Workshop` 클래스에서 `Worker`를 등록하고 요청이 있는 경우 `Worker`를 해제할 수 있도록 허용
3. `Worker`가 여러 `Workshop`에 동시에 등록할 수 있도록 허용
4. `Worker` 클래스는 `Workshop`에 등록되었다면 일을 할 수 있도록 하는`work` 메서드를 가져야 함
5. `Workshop` 클래스는 속한 `Worker`들의 루틴을 실행하는 `executeWorkDay` 메서드가 있어야 함

## Bonuses

다음의 보너스를 제안합니다:

-   `Worker` 클래스에서, 올바른 유형의 첫번째 도구를 가져오는 `GetTool<ToolType>()` 메서드 만들기. 유효하지 않다면 `nullptr` 반환
-   각 `Workshop`은 특정 도구를 보유한 `Worker`만 허용해야 합니다. 워크샵에 등록했지만 필요한 도구가 없는 작업자는 워크샵에 참여할 수 없습니다.
-   또한, `Worker`가 도구를 잃었다면, 작업 중인 `Workshop`에서 자동으로 해제되어야 합니다.

> (대충 Mandatory가 완벽하지 않으면 보너스 평가 안한다는 내용)
